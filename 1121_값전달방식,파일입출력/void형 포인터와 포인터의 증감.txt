포인터의 계산
*p++ :: 포인터의 번지를 ++(만약 4다음 요소값이 6라면 6)
(*p)++ ::현재 포인터가 가리키고 있는 값을 ++(만약 *p==4라면 4+1의 값을 뜻함)

void형 포인터
>>대상체가 없다. void i;라는 선언문 자체가 불가능
1. 임의대상체를 가질 수 있다.
임의의 대상체를 가리킬 수 있다. >>여러가지 타입의 포인터를 받을수 있음.
int *p;
void *vp;
이때 vp=p가 가능하다.
그러나 p=vp는 불가능하다 캐스팅을 해서 p=(int *)vp라고 해야지만 가능하다.
포인터의 값을 출력할때도 그냥 *p라고 해서는 안되고 (int*)vp라고 해야 가능하다.
포인터의 값을 접근하고 싶을때 캐스팅해야됨.
증감연산자도 쓸 수 없다. ++, --을 하려면 그 변수의 크기가 얼마인지 알아야 그만큼 증감하는데 void형이라 그것을 알수가 없기때문에
((int *)vp)++ 불가능
>>캐스트연산자를 괄호로 묶어서 먼저연산되도록 했지만 ++의 피연산자가 캐스팅된형태로 좌변값이 아니기때문에 증감연산 불가능.

>>>값을 읽거나 전후 위치로 이동하는 기능은 빼고 순수하게 메모리의 한 지점을 가리키는 기능을 갖는 포인터이다.

활용형
ex)
memset함수
void *memset(void *s, int c, size_t n);
s라는 배열을 c로 전부 초기화하는 기능
s가 void *로 선언되어 있기때문에 호출문에 캐스트연산자를 쓸 필요없이 배열이름만 적어서 호출하면 된다.


NULL 포인터
0으로 정의되어 있는 포인터 상수값.
어떤 포인터 변수가 NULL값을 가진다면 0번지를 가리키고 있는 것이라 볼 수도 있겠다..
0번지는 메모리 공간의 제일 처음에 해당하기때문에 실제로 존재하는 메모리공간이다. 그러나 0번지는 특수한 공간이므로 시스템공간에 해당한다. 시스템영역에 응용프로그램이 고유 데이터를 저장할수는 없다. 따라서 이런상황이 발생하면 일종의 에러로 간주된다.
따라서 NULL을 리턴했다는것은 0번지를 가리킨다는것이 아니라 해당하는 값이 없다는 뜻과 같다.
0번지는 응용프로그램이 절대 건드릴수없는 영역이기 때문에.
NULL검사를 코드로 짜두면 좀더 안전한 코드가 된다.
NULL은 상수라고 했지만 특별하게 포인터변수와 직접연산이 된다. 
>>ptr=NULL이라고 하면 ptr을 무효화시킨다.
>>if(ptre==NULL)이라고 하면 ptr이 무효한지 검사하는 조건문이다.

